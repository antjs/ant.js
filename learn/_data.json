[{"title":"你好, 世界!","steps":[{"note":"<h3>Welcome !!</h3>\n<p>这是一系列的交互教程, 来帮助你了解 <code>ZUI VIew</code> 的一些特性. </p>\n<p>左侧的三个文本框是可以自由编辑的. 点击<code>执行示例</code>按钮可以执行模板区与 JS 区的内容, 点击<code>执行控制台</code>按钮可以在相同作用域内执行 JS 控制台中的代码.</p>\n<p>任何时候点击<code>重置代码</code>按钮会将代码恢复成本节的默认代码!</p>\n<p>点击下面的按钮可以简单的学习本互动教程的界面使用方法.</p>\n<button class='btn btn-primary' id='intro'>点击开始界面介绍</button>","javascript":"//变量 html 标示上面的模板节点\nconsole.log(html.innerHTML)","html":"<p>你好, 世界</p>","console":"//这里是 javascript 控制台, 在这里输入命令, 可以与现有脚本交互. \n//按 Ctrl + Enter 可以快速执行代码.","noteMarked":"###Welcome !!\n\n这是一系列的交互教程, 来帮助你了解 `ZUI VIew` 的一些特性. \n\n左侧的三个文本框是可以自由编辑的. 点击`执行示例`按钮可以执行模板区与 JS 区的内容, 点击`执行控制台`按钮可以在相同作用域内执行 JS 控制台中的代码.\n\n任何时候点击`重置代码`按钮会将代码恢复成本节的默认代码!\n\n点击下面的按钮可以简单的学习本互动教程的界面使用方法.\n<button class='btn btn-primary' id='intro'>点击开始界面介绍</button>","init":"tutor.off('click #intro')\ntutor.on('click #intro', function() {\n  $('body').off('click.intro');\n  setTimeout(function(){\n    $('body').on('click.intro', function(e) {intro && (!$(e.target).parents('.introjs-tooltip').length) && intro.exit()})\n  },0);\n  var intro = introJs();\n  intro.setOptions({\n    steps:[\n      {\n        element: $('.html .CodeMirror')[0],\n        intro: '这里是 HTML 模板区. 可以自由编辑 HTML 模板内容. 在该区域还支持 zen coding 快速编写哦!'\n      },\n      {\n        element: $('.javascript .CodeMirror')[0],\n        intro: '这里是 Javascript 代码区. 变量 html 代表 HTML 区的 DOM 元素.'\n      },\n      {\n        element: $('.javascript .exe')[0],\n        intro: '点击该按钮将会执行 HTML 区及 JS 区的内容, 并将其显示到内容预览区.'\n      },\n      {\n        element: $('.console .CodeMirror')[0],\n        intro: '这里是 Javascript 控制台区. 可以输入一些 js 代码来与上面的代码做些交互'\n      },\n      {\n        element: $('.console .exe')[0],\n        intro: '在控制台区写些代码, 然后点击该按钮, 看看执行的情况.'\n      },\n      {\n        element: $('#reset')[0],\n        intro: '修改了代码之后. 点击该按钮将会恢复教程原来的代码.'\n      },\n      {\n        element: $('.output')[0],\n        intro: '代码的运行后, HTML 内容将展现在这里.'\n      }\n    ]\n  });\n  intro.start();\n})"},{"note":"<h3>基础模板功能</h3>\n<p>模板中两对大括号(<code>{{name}}</code>)表示数据变量, 其中的值对应数据中相同路径的值.</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>别惹{{name}}!<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>我们给它添加一些数据:</p>\n<pre><code><span class=\"keyword\">var</span> view = <span class=\"keyword\">new</span> ZUI.View(template, {\n  data: {\n    name: <span class=\"string\">'蚂蚁'</span>\n  }\n});</code></pre>\n<p>将以上的内容分别输入右侧的模板栏和JS栏后, 执行即可在下面的预览区域看到渲染后的效果!</p>\n","html":"<p>别惹{{name}}!</p>","javascript":"//变量 template 标示上面的模板节点\nconsole.log(html.innerHTML)","console":"","fixCode":{"javascript":"var view = new ZUI.View(html, {\n  data: {\n    name: '蚂蚁'\n  }\n});","html":"<p>别惹{{name}}!</p>","console":""},"noteMarked":"### 基础模板功能\n\n模板中两对大括号(<code>{{name}}</code>)表示数据变量, 其中的值对应数据中相同路径的值.\n\n```\n<p>别惹{{name}}!</p>\n```\n我们给它添加一些数据:\n\n```\nvar view = new ZUI.View(template, {\n  data: {\n    name: '蚂蚁'\n  }\n});\n```\n将以上的内容分别输入右侧的模板栏和JS栏后, 执行即可在下面的预览区域看到渲染后的效果!"},{"note":"<p><h3>绑定数据</h3></p>\n<p><p>如果想改变已经渲染好的模板的内容, 传统的方式只能通过选择器找到要更改的内容手动更改它, 或者重新渲染一遍模板.</p></p>\n<p><p>现在, 我们只需将设置新的数据就能魔法般的更改所有相关内容. 如我们想更改<code>name</code>的内容:</p></p>\n<pre><code>view.<span class=\"operator\"><span class=\"keyword\">set</span>(<span class=\"string\">'name'</span>, <span class=\"string\">'Ant'</span>)</code></pre>\n<p><code>view.set</code> 也可以接受一个对象来更改几条数据:</p>\n<pre><code class=\"lang-javascript\"><span class=\"tag\">view</span><span class=\"class\">.set</span>(<span class=\"rules\">{\n  <span class=\"rule\"><span class=\"attribute\">name</span>:<span class=\"value\"> <span class=\"string\">'Formicidae'</span>\n, greeting: <span class=\"string\">'你好'</span> \n}</span></span></span>)</code></pre>\n<p>可以在右下侧的控制台里执行上面两条命令, 看看效果</p>\n","html":"<p>别惹{{name}}!</p>\n<p>{{greeting}} {{name}}!</p>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    name: '蚂蚁'\n  }\n});","console":"view.set('name', 'Ant')","fixCode":{"console":"view.set({\n  name: 'Formicidae'\n, greeting: '你好'\n})"},"autorun":true,"noteMarked":"<h3>绑定数据</h3>\n<p>如果想改变已经渲染好的模板的内容, 传统的方式只能通过选择器找到要更改的内容手动更改它, 或者重新渲染一遍模板.</p>\n<p>现在, 我们只需将设置新的数据就能魔法般的更改所有相关内容. 如我们想更改<code>name</code>的内容:</p>\n```\nview.set('name', 'Ant')\n```\n\n`view.set` 也可以接受一个对象来更改几条数据:\n\n```javascript\nview.set({\n  name: 'Formicidae'\n, greeting: '你好' \n})\n```\n\n可以在右下侧的控制台里执行上面两条命令, 看看效果"},{"note":"<h3>多层数据</h3>\n<p>我们使用<code>.</code> 表示法来表示对象的层级, 就像 javascript 中的深层对象表示法一样. 比如对于 <code>data.persion.name</code>: </p>\n<pre><code><span class=\"keyword\">var</span> data = {person: {name: <span class=\"string\">'Ant'</span>}}</code></pre>\n<p>在模板中的表示方式应该是: <code>{{person.name}}</code></p>\n<p>使用 <code>view.get(keypath)</code> 来获取数据, <code>keypath</code> 表示内容在数据中的路径. 如运行下面的代码将得到 &#39;Ant&#39;.</p>\n<pre><code>view.<span class=\"keyword\">get</span>(<span class=\"string\">'person.name`)</code></pre>\n","fixCode":{"console":"alert(view.get('person.name'))","html":"<p>别惹{{person.name}}!</p>"},"html":"<p>别惹{{person.name}}!</p>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    person: {name: 'Ant'}\n  }\n});","console":"view.set('person.name', '蚂蚁')","autorun":true,"noteMarked":"### 多层数据\n\n我们使用<code>.</code> 表示法来表示对象的层级, 就像 javascript 中的深层对象表示法一样. 比如对于 `data.persion.name`: \n\n```\nvar data = {person: {name: 'Ant'}}\n```\n\n在模板中的表示方式应该是: `{{person.name}}`\n\n使用 `view.get(keypath)` 来获取数据, `keypath` 表示内容在数据中的路径. 如运行下面的代码将得到 'Ant'.\n\n```\nview.get('person.name`)\n```\n\n","init":""},{"autorun":true,"note":"<h3>动态属性</h3>\n<p>不光是普通的文本内容, 对于 HTML 属性我们同样可以将其与数据动态绑定:</p>\n\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>我是 <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">style</span>=<span class=\"value\">\"color: {{color}}\"</span>&gt;</span>{{color}}<span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span> 蚂蚁<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p><p></p><p>改变 <code>color</code> 的值即可改变 span 标签的 style 属性: <code>view.set(&#39;color&#39;, &#39;blue&#39;)</code></p><p></p></p>\n<h3>IE 与 <code>z-style</code></h3>\n\n<p><p>如果你使用的是 IE 浏览器, 上面的例子运行效果和我们预想的情况可能会有些不一样. ZUI View 使用的模板是真实的 DOM 树, 而 IE 会将节点中 <code>style</code> 属性的不合法值直接丢弃, 这样会导致属性模板不起作用. </p>\n<p>为了解决这个问题, 在 <code>style</code> 属性名前需要加上<code>z-</code>前缀:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>我是 <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">z-style</span>=<span class=\"value\">\"color: {{color}}\"</span>&gt;</span>{{color}}<span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span> 蚂蚁<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>事实上, 不光是 style 属性, <code>z-</code>属性前缀可以添加到所有 HTML 属性前面. 模板解析时会自动将其转换成原来的属性.</p>\n","html":"<p>我是 <span style=\"color: {{color}}\">{{color}}</span> 蚂蚁</p>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    color: 'red'\n  }\n});","console":"view.set('color', 'blue')","fixCode":{"html":"<p>我是 <span z-style=\"color: {{color}}\">{{color}}</span> 蚂蚁</p>"},"noteMarked":"###动态属性\n\n<p>不光是普通的文本内容, 对于 HTML 属性我们同样可以将其与数据动态绑定:</p>\n\n```html\n<p>我是 <span style=\"color: {{color}}\">{{color}}</span> 蚂蚁</p>\n```\n<p></p><p>改变 <code>color</code> 的值即可改变 span 标签的 style 属性: <code>view.set('color', 'blue')</code></p><p></p>\n<h3>IE 与 <code>z-style</code></h3>\n\n<p>如果你使用的是 IE 浏览器, 上面的例子运行效果和我们预想的情况可能会有些不一样. ZUI View 使用的模板是真实的 DOM 树, 而 IE 会将节点中 `style` 属性的不合法值直接丢弃, 这样会导致属性模板不起作用. \n\n为了解决这个问题, 在 `style` 属性名前需要加上<code>z-</code>前缀:\n```html\n<p>我是 <span z-style=\"color: {{color}}\">{{color}}</span> 蚂蚁</p>\n```\n\n事实上, 不光是 style 属性, <code>z-</code>属性前缀可以添加到所有 HTML 属性前面. 模板解析时会自动将其转换成原来的属性.\n"}]},{"steps":[{"noteMarked":"### 双向绑定\n所谓的双向绑定, 即是在数据模型层 `Model` 和界面视图层 `View` 当中任何一层发生了变化, 都会将该变化自动更新到另一层中.\n\nZUI View 为大部分表单元素提供了内置的双向绑定机制. 在表单元素中添加属性 `z-model` 就可以将该元素和对应数据间建立起双向绑定. 如:\n\n```\n<label>用户名: <input type=text z-model=username /></label>\n<label>密 码: <input type=password z-model=password /></label>\n<label>简介: <textarea z-model=resume></textarea></label>\n<pre>\nHi {{username}}!\n  我知道你的密码: {{password}}\n{{resume}}\n</pre>\n```\n\n请试着在内容预览区的表单中输入一些内容.\n\n一旦用户向输入框中输入内容, 其输入的值就会自动更新到 `model` 层, `model` 更新后会反馈到其他使用该数据的地方.\n\n在控制台中直接输入一下代码看有什么效果?\n```\nview.set('username', 'Ant')\n```","note":"<h3>双向绑定</h3>\n<p>所谓的双向绑定, 即是在数据模型层 <code>Model</code> 和界面视图层 <code>View</code> 当中任何一层发生了变化, 都会将该变化自动更新到另一层中.</p>\n<p>ZUI View 为大部分表单元素提供了内置的双向绑定机制. 在表单元素中添加属性 <code>z-model</code> 就可以将该元素和对应数据间建立起双向绑定. 如:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>用户名: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">text</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">username</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>密 码: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">password</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">password</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>简介: <span class=\"tag\">&lt;<span class=\"title\">textarea</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">resume</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">pre</span>&gt;</span>\nHi {{username}}!\n  我知道你的密码: {{password}}\n{{resume}}\n<span class=\"tag\">&lt;/<span class=\"title\">pre</span>&gt;</span></code></pre>\n<p>请试着在内容预览区的表单中输入一些内容.</p>\n<p>一旦用户向输入框中输入内容, 其输入的值就会自动更新到 <code>model</code> 层, <code>model</code> 更新后会反馈到其他使用该数据的地方.</p>\n<p>在控制台中直接输入一下代码看有什么效果?</p>\n<pre><code>view.<span class=\"operator\"><span class=\"keyword\">set</span>(<span class=\"string\">'username'</span>, <span class=\"string\">'Ant'</span>)</code></pre>\n","init":"","html":"<label>用户名: <input type=text z-model=username /></label>\n<label>密 码: <input type=password z-model=password /></label>\n<label>简介: <textarea z-model=resume></textarea></label>\n<pre>\nHi {{username}}!\n  我知道你的密码: {{password}}\n{{resume}}\n</pre>","javascript":"var view = new ZUI.View(html, {data: {}});","console":" ","autorun":true,"fixCode":{"console":"view.set('username', 'Ant')"}},{"noteMarked":"### 复选框和单选框\n\n对于一个复选框, 一般我们会关注其选中状态, 即其 `checked` 属性的值, `true` or `false`. \n\n复选框绑定的数据通常是一个布尔值. 如:\n```\n<label>写代码: <input type=checkbox z-model=done /></label>\n<p>是否完成: {{done}}</p>\n```\n\n而单选框通常都有一组值, 每次只会选中一个. 单选框绑定的是其选中的值:\n\n```\n<label>选择一个颜色: </label>\n<label>蓝色: <input type=radio z-model=color value=blue /></label>\n<label>红色: <input type=radio z-model=color value=red /></label>\n<label>绿色: <input type=radio z-model=color value=green /></label>\n<p>选中的是 <span z-style='color: {{color}}'>{{color}}</span> 色</p>\n```","note":"<h3>复选框和单选框</h3>\n<p>对于一个复选框, 一般我们会关注其选中状态, 即其 <code>checked</code> 属性的值, <code>true</code> or <code>false</code>. </p>\n<p>复选框绑定的数据通常是一个布尔值. 如:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>写代码: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">checkbox</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">done</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>是否完成: {{done}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>而单选框通常都有一组值, 每次只会选中一个. 单选框绑定的是其选中的值:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>选择一个颜色: <span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>蓝色: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">radio</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">color</span> <span class=\"attribute\">value</span>=<span class=\"value\">blue</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>红色: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">radio</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">color</span> <span class=\"attribute\">value</span>=<span class=\"value\">red</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">label</span>&gt;</span>绿色: <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">radio</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">color</span> <span class=\"attribute\">value</span>=<span class=\"value\">green</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">label</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>选中的是 <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">z-style</span>=<span class=\"value\">'color: {{color}}'</span>&gt;</span>{{color}}<span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span> 色<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n","html":"<label>写代码: <input type=checkbox z-model=done /></label>\n<p>是否完成: {{done}}</p>\n<label>选择一个颜色: </label>\n<label>蓝色: <input type=radio z-model=color value=blue /></label>\n<label>红色: <input type=radio z-model=color value=red /></label>\n<label>绿色: <input type=radio z-model=color value=green /></label>\n<p>选中的是 <span z-style='color: {{color}}'>{{color}}</span> 色</p>","javascript":"var view = new ZUI.View(html, {data: {}});","console":" ","init":"","autorun":true},{"noteMarked":"### 下拉列表\n\n`select` 控件分为单选和多选. 单选下拉列表绑定的数据是其选中 `option` 元素的 `value` 值:\n\n```\n<select z-model=name>\n  <option value=\"ant\">ant</option>\n  <option value=\"bee\">bee</option>\n</select>\n<p> 单选下拉列表选中的是: {{name}}</p>\n```\n而对于多选的下拉列表. 其绑定的数据是包含所有选中 `option` 元素 `value` 值的数组:\n```\n<select z-model=name2 multiple>\n  <option value=\"ant\">ant</option>\n  <option value=\"bee\">bee</option>\n  <option value=\"cicada\">cicada</option>\n  <option value=\"dragonfly\">dragonfly</option>\n</select>\n<p>多选下拉列表选中的值有: {{name2}}</p>\n```\n在控制台中输入下面的代码, 可以发现 `name2` 是一个数组:\n```\nalert(({}).toString.call(view.get('name2')))\n```","note":"<h3>下拉列表</h3>\n<p><code>select</code> 控件分为单选和多选. 单选下拉列表绑定的数据是其选中 <code>option</code> 元素的 <code>value</code> 值:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">select</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">name</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"ant\"</span>&gt;</span>ant<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"bee\"</span>&gt;</span>bee<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">select</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span> 单选下拉列表选中的是: {{name}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>而对于多选的下拉列表. 其绑定的数据是包含所有选中 <code>option</code> 元素 <code>value</code> 值的数组:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">select</span> <span class=\"attribute\">z-model</span>=<span class=\"value\">name2</span> <span class=\"attribute\">multiple</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"ant\"</span>&gt;</span>ant<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"bee\"</span>&gt;</span>bee<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"cicada\"</span>&gt;</span>cicada<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"dragonfly\"</span>&gt;</span>dragonfly<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">select</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>多选下拉列表选中的值有: {{name2}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>在控制台中输入下面的代码, 可以发现 <code>name2</code> 是一个数组:</p>\n<pre><code>alert(({}).toString.<span class=\"operator\"><span class=\"keyword\">call</span>(<span class=\"keyword\">view</span>.<span class=\"keyword\">get</span>(<span class=\"string\">'name2'</span>)))</code></pre>\n","html":"<select z-model=name>\n  <option value=\"ant\">ant</option>\n  <option value=\"bee\">bee</option>\n</select>\n<p> 单选下拉列表选中的是: {{name}}</p>\n<select z-model=name2 multiple>\n  <option value=\"ant\">ant</option>\n  <option value=\"bee\">bee</option>\n  <option value=\"cicada\">cicada</option>\n  <option value=\"dragonfly\">dragonfly</option>\n</select>\n<p>多选下拉列表选中的值有: {{name2}}</p>","javascript":"var view = new ZUI.View(html, {data: {}});","console":" ","fixCode":{"console":" alert(({}).toString.call(view.get('name2')))"},"init":"","autorun":true},{"noteMarked":"### 延时绑定\n之前的教程中, 在文本框输入内容的时, 输入的内容在输入完成后立即更新到其他地方. \n\n我们有时候或许不需要这种改变太频繁的绑定行为. ZUI View 提供了一种延时绑定的设置. 开启后, 数据同步的动作会在整个文本框的输入完成 (该元素的焦点丢失) 后发生. \n\n开启延时绑定需要在 ZUI View 的构造函数的第二个参数选项中传入 `lazy: true`\n```\nvar view = new ZUI.View(html, {data: {}, lazy: true});\n```\n\n延时绑定和及时绑定其实是和浏览器文本框的 `input` 事件和 `change` 事件相关的. 延时绑定是 ZUI View 监听的是文本框的 `change` 事件, 而非延时绑定时监听的是 `input` 事件.","note":"<h3>延时绑定</h3>\n<p>之前的教程中, 在文本框输入内容的时, 输入的内容在输入完成后立即更新到其他地方. </p>\n<p>我们有时候或许不需要这种改变太频繁的绑定行为. ZUI View 提供了一种延时绑定的设置. 开启后, 数据同步的动作会在整个文本框的输入完成 (该元素的焦点丢失) 后发生. </p>\n<p>开启延时绑定需要在 ZUI View 的构造函数的第二个参数选项中传入 <code>lazy: true</code></p>\n<pre><code><span class=\"keyword\">var</span> view = <span class=\"keyword\">new</span> ZUI.View(html, {data: {}, lazy: <span class=\"keyword\">true</span>});</code></pre>\n<p>延时绑定和及时绑定其实是和浏览器文本框的 <code>input</code> 事件和 <code>change</code> 事件相关的. 延时绑定是 ZUI View 监听的是文本框的 <code>change</code> 事件, 而非延时绑定时监听的是 <code>input</code> 事件.</p>\n","javascript":"var view = new ZUI.View(html, {data: {}, lazy: true});","console":" ","html":"<label>用户名: <input type=text z-model=username /></label>\n<label>密 码: <input type=password z-model=password /></label>\n<label>简介: <textarea z-model=resume></textarea></label>\n<pre>\nHi {{username}}!\n  我知道你的密码: {{password}}\n{{resume}}\n</pre>","autorun":true,"init":""}],"title":"双向绑定"},{"steps":[{"noteMarked":"### z-if\n拥有 `z-if` 属性的节点表示该节点是一个条件节点. \n\n对于元素 \n\n```\n<p z-if=war>- 第三次世界大战宣言</p>\n```\n\n当 `war` 值为 `true` 时该元素显示到 DOM 树中, 如果为 `false` 该元素将从 DOM 树中被删除.\n\n试着在 JS 控制台中改变 `war` 值, 看看内容的变化:\n\n```\nview.set('war', true);\n```","note":"<h3>z-if</h3>\n<p>拥有 <code>z-if</code> 属性的节点表示该节点是一个条件节点. </p>\n<p>对于元素 </p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">z-if</span>=<span class=\"value\">war</span>&gt;</span>- 第三次世界大战宣言<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>当 <code>war</code> 值为 <code>true</code> 时该元素显示到 DOM 树中, 如果为 <code>false</code> 该元素将从 DOM 树中被删除.</p>\n<p>试着在 JS 控制台中改变 <code>war</code> 值, 看看内容的变化:</p>\n<pre><code>view.<span class=\"operator\"><span class=\"keyword\">set</span>(<span class=\"string\">'war'</span>, <span class=\"keyword\">true</span>);</span></code></pre>\n","html":"<p>疯狂的战争再一次扩散到全世界，为克服重重困难生存下来我们必须再次做好准备...在我们共同对抗新的邪恶之际，让我们一起祈祷，为我们的国家，为仁人志士，不论他们身在何处。上帝保佑你们。</p>\n<p z-if=war>--- 第三次世界大战宣言</p>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    war: false\n  }\n})","console":" ","fixCode":{"console":"view.set('war', true);"}},{"noteMarked":"### 如果没有\n\n使用 `^` 标记表示一个值为 `false` 时显示, 而为 `true` 时不显示.\n\n```\n<p z-if=^nowar>--- 第三次世界大战宣言</p>\n```\n\n将`nowar` 的值设为 `false` 将会使该节点显示\n\n```\nview.set('nowar', false);\n```\n\n需要注意的是 javascript 中的假值包括: `''`, `undefined`, `null`, `0`, `NaN`, `false`.\n","note":"<h3>如果没有</h3>\n<p>使用 <code>^</code> 标记表示一个值为 <code>false</code> 时显示, 而为 <code>true</code> 时不显示.</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">z-if</span>=<span class=\"value\">^nowar</span>&gt;</span>--- 第三次世界大战宣言<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>将<code>nowar</code> 的值设为 <code>false</code> 将会使该节点显示</p>\n<pre><code>view.<span class=\"operator\"><span class=\"keyword\">set</span>(<span class=\"string\">'nowar'</span>, <span class=\"keyword\">false</span>);</span></code></pre>\n<p>需要注意的是 javascript 中的假值包括: <code>&#39;&#39;</code>, <code>undefined</code>, <code>null</code>, <code>0</code>, <code>NaN</code>, <code>false</code>.</p>\n","fixCode":{"console":" view.set('nowar', '')"},"html":"<p>疯狂的战争再一次扩散到全世界，为克服重重困难生存下来我们必须再次做好准备...在我们共同对抗新的邪恶之际，让我们一起祈祷，为我们的国家，为仁人志士，不论他们身在何处。上帝保佑你们。</p>\n<p z-if=^nowar>--- 第三次世界大战宣言</p>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    nowar: true\n  }\n})","console":" view.set('nowar', false)"}],"title":"条件节点"},{"steps":[{"noteMarked":"### z-repeat 属性\n \n一个元素如果有了 `z-repeat` 属性, 这个元素就将和其值对应的数组绑定在一起.  根据数组的数量, 该元素也会复制同样的个数.\n\n如模板:\n```html\n<ul>\n  <li z-repeat='todo.list'>{{title}}</li>\n</ul>\n```\n\n对应有数据:\n```\nvar data = {\n  todo: {\n    list: [{title: '开机'}, {title: '关机'}]\n  }\n}\n```\n最终会渲染出 HTML:\n```\n<ul>\n  <li>开机</li>\n  <li>写代码</li>\n</ul>\n```\n请注意到循环元素内(包括该元素自身)的变量作用域会发生变化,  其基准作用域会变到数组元素内部. 模板中 `{{title}}` 对应的是 `todo.list` 数组中子元素 `title` 的值.\n```html\n<ul>\n <li z-repeat='todo.list' title={{title}}>{{title}}</li>\n</ul>\n```","note":"<h3>z-repeat 属性</h3>\n<p>一个元素如果有了 <code>z-repeat</code> 属性, 这个元素就将和其值对应的数组绑定在一起.  根据数组的数量, 该元素也会复制同样的个数.</p>\n<p>如模板:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">ul</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">li</span> <span class=\"attribute\">z-repeat</span>=<span class=\"value\">'todo.list'</span>&gt;</span>{{title}}<span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">ul</span>&gt;</span></code></pre>\n<p>对应有数据:</p>\n<pre><code><span class=\"keyword\">var</span> data = {\n  todo: {\n    <span class=\"keyword\">list</span>: [{title: <span class=\"string\">'开机'</span>}, {title: <span class=\"string\">'关机'</span>}]\n  }\n}</code></pre>\n<p>最终会渲染出 HTML:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">ul</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">li</span>&gt;</span>开机<span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">li</span>&gt;</span>写代码<span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">ul</span>&gt;</span></code></pre>\n<p>请注意到循环元素内(包括该元素自身)的变量作用域会发生变化,  其基准作用域会变到数组元素内部. 模板中 <code>{{title}}</code> 对应的是 <code>todo.list</code> 数组中子元素 <code>title</code> 的值.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">ul</span>&gt;</span>\n <span class=\"tag\">&lt;<span class=\"title\">li</span> <span class=\"attribute\">z-repeat</span>=<span class=\"value\">'todo.list'</span> <span class=\"attribute\">title</span>=<span class=\"value\">{{title}}</span>&gt;</span>{{title}}<span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">ul</span>&gt;</span></code></pre>\n","fixCode":{"console":" ","html":"<ul>\n  <li z-repeat='todo.list' title={{title}}>{{title}}</li>\n</ul>"},"html":"<ul>\n  <li z-repeat='todo.list'>{{title}}</li>\n</ul>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    todo: {\n      list: [{title: '开机'}, {title: '关机'}]\n    }\n  }\n})","console":" ","init":"","autorun":true},{"noteMarked":"### 简单数组\n对于简单类型数据的数组元素, 使用 `{{.}}` 来指代该数组子元素本身:\n```\n<ul>\n  <li z-repeat='cities'>{{.}}</li>\n</ul>\n```\n```\nvar view = new ZUI.View(html, {data: {\n  cities: ['北京', '上海', '广州', '深圳']\n}})\n```","note":"<h3>简单数组</h3>\n<p>对于简单类型数据的数组元素, 使用 <code>{{.}}</code> 来指代该数组子元素本身:</p>\n<pre><code>&lt;ul&gt;\n  &lt;li z-repeat=&#39;cities&#39;&gt;{{.}}&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<pre><code>var view = new ZUI.View(html, {data: {\n  cities: [&#39;北京&#39;, &#39;上海&#39;, &#39;广州&#39;, &#39;深圳&#39;]\n}})</code></pre>\n","html":"<ul>\n  <li z-repeat='cities'>{{.}}</li>\n</ul>","javascript":"var view = new ZUI.View(html, {data: {\n  cities: ['北京', '上海', '广州', '深圳']\n}})","console":" "},{"noteMarked":"### 与数组交互\n\n在 javascript 中更改数组元素一般会这么做:\n\n```\nview.data.todo.list[0].title = '运行程序';\n```\n这样做对于 ZUI View 的问题是, 它并不知道数据发生了变化, 它也不会更新 HTML. 如果我们这样更改了数据, 这时需要使用 `view.update` 方法主动告诉 ZUI View 更新 HTML 视图:\n```\nview.update('todo.list')\n```\n\n\n对于普通数据会用 `view.set` 方法来修改数据, 完成界面自动更新. 对于数组数据同样适用. \n```\n view.set('todo.list[1].title', '关闭程序')\n```\n之前我们使用 `.` 点表示法来表示深度对象, 其实也可以使用更熟悉的下标表示法`[]`来表示数组.\n","note":"<h3>与数组交互</h3>\n<p>在 javascript 中更改数组元素一般会这么做:</p>\n<pre><code>view.data.todo.list[0].title = '运行程序';</code></pre>\n<p>这样做对于 ZUI View 的问题是, 它并不知道数据发生了变化, 它也不会更新 HTML. 如果我们这样更改了数据, 这时需要使用 <code>view.update</code> 方法主动告诉 ZUI View 更新 HTML 视图:</p>\n<pre><code>view.update('todo.list')</code></pre>\n<p>对于普通数据会用 <code>view.set</code> 方法来修改数据, 完成界面自动更新. 对于数组数据同样适用. </p>\n<pre><code> view.set('todo.list[1].title', '关闭程序')</code></pre>\n<p>之前我们使用 <code>.</code> 点表示法来表示深度对象, 其实也可以使用更熟悉的下标表示法<code>[]</code>来表示数组.</p>\n","autorun":true,"fixCode":{"html":"<ul>\n  <li z-repeat='todo.list'>{{title}}</li>\n</ul>","console":" view.set('todo.list[1].title', '关闭程序')"},"javascript":"var view = new ZUI.View(html, {\n  data: {\n    todo: {\n      list: [{title: '开机'}, {title: '关机'}]\n    }\n  }\n})","console":"view.data.todo.list[0].title = '运行程序';\nview.update('todo.list')","html":"<ul>\n  <li z-repeat='todo.list'>{{title}}</li>\n</ul>","init":""},{"noteMarked":"### 使用数组方法\n实际上使用 `view.set` 方法更改数组数据显得略笨拙. Javascript 中数组对象拥有自己的一套方法来更改其数据, ZUI View 封装了部分方法, 调用这些方法后将会自动的更新 HTML 的视图内容. 封装的方法包括: `push`, `pop`, `shift`, `unshift`, `splice`, `reverse`, `sort`.\n\n在控制台分别输入以下代码看看运行的效果:\n```\nvar list = view.get('todo.list');\nlist.push({title: '重启'});\n```\n\n```\nview.data.todo.list.reverse();\n```","note":"<h3>使用数组方法</h3>\n<p>实际上使用 <code>view.set</code> 方法更改数组数据显得略笨拙. Javascript 中数组对象拥有自己的一套方法来更改其数据, ZUI View 封装了部分方法, 调用这些方法后将会自动的更新 HTML 的视图内容. 封装的方法包括: <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>reverse</code>, <code>sort</code>.</p>\n<p>在控制台分别输入以下代码看看运行的效果:</p>\n<pre><code>var list = view.get(&#39;todo.list&#39;);\nlist.push({title: &#39;重启&#39;});</code></pre>\n<pre><code>view.data.todo.list.reverse();</code></pre>\n","html":"<ul>\n  <li z-repeat='todo.list'>{{title}}</li>\n</ul>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    todo: {\n      list: [{title: '开机'}, {title: '关机'}]\n    }\n  }\n})","console":"var list = view.get('todo.list');\nlist.push({title: '重启'});","autorun":true,"init":"","fixCode":{"console":"view.data.todo.list.reverse();"}}],"title":"循环节点"},{"steps":[{"noteMarked":"如果数据当中包含有 HTML标签 内容, 使用双大括号 `{{}}` 表示这些数据时会自动将 HTML 标签内容转义. 比如对于数据:\n```javascript\nvar data = {\n  content: '<h1>标题</h1><p>从前有座山...</p>'\n};\n```\n使用模板:\n```\n<div>{{content}}</div>\n```\n解析后生成的内容是转义后的 HTML:\n```\n<div>&lt;h1&gt;标题&lt;/h1&gt;&lt;p&gt;从前有座山...&lt;/p&gt;</div>\n```\n这样做是为了能够在 HTML 页面当中显示 HTML 文本内容.\n\n而我们又有可能需要在 HTML 页面当中解析并使用这些标签. 这是我们需要使用非转义的变量占位符. 非转义占位符使用三组大括号标示: `{{{html}}}`\n```\n<div>{{{content}}}</div>\n```","note":"<p>如果数据当中包含有 HTML标签 内容, 使用双大括号 <code>{{}}</code> 表示这些数据时会自动将 HTML 标签内容转义. 比如对于数据:</p>\n<pre><code class=\"lang-javascript\">var data = {\n  content: '<span class=\"tag\">&lt;<span class=\"title\">h1</span>&gt;</span>标题<span class=\"tag\">&lt;/<span class=\"title\">h1</span>&gt;</span><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>从前有座山...<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span>'\n};</code></pre>\n<p>使用模板:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">div</span>&gt;</span>{{content}}<span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n<p>解析后生成的内容是转义后的 HTML:</p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">div</span>&gt;</span>&amp;lt;h1&amp;gt;标题&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;从前有座山...&amp;lt;/p&amp;gt;<span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n<p>这样做是为了能够在 HTML 页面当中显示 HTML 文本内容.</p>\n<p>而我们又有可能需要在 HTML 页面当中解析并使用这些标签. 这是我们需要使用非转义的变量占位符. 非转义占位符使用三组大括号标示: <code>{{{html}}}</code></p>\n<pre><code><span class=\"tag\">&lt;<span class=\"title\">div</span>&gt;</span>{{{content}}}<span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n","html":"<div>{{content}}</div>","javascript":"var view = new ZUI.View(html, {\n  data: {\n    content: '<h1>标题</h1><p>从前有座山...</p>'\n  }\n})","console":" ","fixCode":{"html":"<div>{{{content}}}</div>"},"init":""}],"title":"非转义 HTML"},{"steps":[{"noteMarked":"### 基本使用\n有时候我们需要使用一些共享的模板, 这些模板需要在其他各个模板中使用. 在模板中插入另一个模板需要使用 `{{> partial}}` 标示符:\n```html\n<h2>我是父模板</h2>\n<p>需要在这里使用一个子模板: {{> content}}</p>\n```\n模板中的子模板名需要在 ZUI View 构造函数中定义: \n```javascript\nvar view = new ZUI.View(html, {\n  data: {}\n, partials: {\n    content: '子模板在此!'\n  }\n})\n```\n子模板的使用有两点需要注意:\n\n - 子模板标示符只能使用在文本节点当中, 在属性节点中无效.\n\n - 如果使用 DOM 对象作为子模板, 该对象将插入到父模板当中, 该节点将从原来的位置移除.","note":"<h3>基本使用</h3>\n<p>有时候我们需要使用一些共享的模板, 这些模板需要在其他各个模板中使用. 在模板中插入另一个模板需要使用 <code>{{&gt; partial}}</code> 标示符:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">h2</span>&gt;</span>我是父模板<span class=\"tag\">&lt;/<span class=\"title\">h2</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>需要在这里使用一个子模板: {{&gt; content}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>模板中的子模板名需要在 ZUI View 构造函数中定义: </p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> view = <span class=\"keyword\">new</span> ZUI.View(html, {\n  data: {}\n, partials: {\n    content: <span class=\"string\">'子模板在此!'</span>\n  }\n})</code></pre>\n<p>子模板的使用有两点需要注意:</p>\n<ul>\n<li><p>子模板标示符只能使用在文本节点当中, 在属性节点中无效.</p>\n</li>\n<li><p>如果使用 DOM 对象作为子模板, 该对象将插入到父模板当中, 该节点将从原来的位置移除.</p>\n</li>\n</ul>\n","html":"<h2>我是父模板</h2>\n<p>需要在这里使用一个子模板: {{> content}}</p>","javascript":"var view = new ZUI.View(html, {\n  data: {}\n, partials: {\n    content: '子模板在此!'\n  }\n})"},{"note":"<h3>非转义子模板</h3>\n<p>子模板中可能会包含 HTML 标签, 对于标签转义的处理, 子模板标签的处理类似一般的变量标签. 用三对大括号表示非转义 HTML. 如:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span>&gt;</span>需要在这里使用一个非转义的子模板: {{{&gt; content}}}<span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>对于 DOM 对象的子模板, 由于其本身即是 DOM 节点, 并不存在是否转义的问题, 子模板标签是 3 对大括号或 2 对大括号对其没有意义.</p>\n","javascript":"var view = new ZUI.View(html, {\n  data: {}\n, partials: {\n    content: '<h3>子模板在此!</h3>'\n  }\n})","html":"<h2>我是父模板</h2>\n<p>需要在这里使用一个非转义的子模板: {{{> content}}}</p>","noteMarked":"### 非转义子模板\n\n子模板中可能会包含 HTML 标签, 对于标签转义的处理, 子模板标签的处理类似一般的变量标签. 用三对大括号表示非转义 HTML. 如:\n```html\n<p>需要在这里使用一个非转义的子模板: {{{> content}}}</p>\n```\n\n对于 DOM 对象的子模板, 由于其本身即是 DOM 节点, 并不存在是否转义的问题, 子模板标签是 3 对大括号或 2 对大括号对其没有意义."}],"title":"子模板"},{"steps":[{"noteMarked":"ZUI View 中的事件是通过 jQuery 和 DOM 树绑定的. ZUI View 的自定义事件在 DOM 树中可以监听到, 同样的 DOM 事件也可以在 ZUI View 中监听. \n\n比如, 我们可以用 `view.on('click', handler)` 来监听 `view.el` 中的所有点击事件.\n\n```javascript\nvar view = new ZUI.View(html, {data: {}})\nview.on('click', function(e){\n  alert(e.target.innerHTML);\n});\n```\n\n**事件委托:**\n\n模板内具体某个元素的事件监听可以通过事件委托的方式完成:\n```javascript\nview.on('click button', function() {\n  alert('点击了按钮');\n})\n```\n类似 jQuery 中的事件监听方法. `view.on` 的第一个参数是事件名, 不同于 jQuery 的是, 子元素的选择器也在第一个参数中, 和事件名以空格分开.\n\n由于 `view.on` 监听的事件都是通过监听 `view.el` 来委托完成的, 所以那些那些不冒泡的事件(如 `focus, blur` 等)不能通过 `view.on` 方法来监听.\n","note":"<p>ZUI View 中的事件是通过 jQuery 和 DOM 树绑定的. ZUI View 的自定义事件在 DOM 树中可以监听到, 同样的 DOM 事件也可以在 ZUI View 中监听. </p>\n<p>比如, 我们可以用 <code>view.on(&#39;click&#39;, handler)</code> 来监听 <code>view.el</code> 中的所有点击事件.</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> view = <span class=\"keyword\">new</span> ZUI.View(html, {data: {}})\nview.on(<span class=\"string\">'click'</span>, <span class=\"keyword\">function</span>(e){\n  alert(e.target.innerHTML);\n});</code></pre>\n<p><strong>事件委托:</strong></p>\n<p>模板内具体某个元素的事件监听可以通过事件委托的方式完成:</p>\n<pre><code class=\"lang-javascript\">view.on(<span class=\"string\">'click button'</span>, <span class=\"keyword\">function</span>() {\n  alert(<span class=\"string\">'点击了按钮'</span>);\n})</code></pre>\n<p>类似 jQuery 中的事件监听方法. <code>view.on</code> 的第一个参数是事件名, 不同于 jQuery 的是, 子元素的选择器也在第一个参数中, 和事件名以空格分开.</p>\n<p>由于 <code>view.on</code> 监听的事件都是通过监听 <code>view.el</code> 来委托完成的, 所以那些那些不冒泡的事件(如 <code>focus, blur</code> 等)不能通过 <code>view.on</code> 方法来监听.</p>\n","html":"<div id=view>\n  <p>对于 DOM 事件, 可以使用 view.on 来监听</p>\n  <button class='btn btn-primary'>点击此处</button>\n</div>","javascript":"var view = new ZUI.View(document.getElementById('view'), {data: {}})\nview.on('click', function(e){\n  alert(e.target.innerHTML);\n});","fixCode":{"console":"view.on('click button.btn', function() {\n  alert('点击了按钮');\n})"},"autorun":true,"init":""},{"noteMarked":"### ZUI View 的事件\n\nZUI View 目前自带有两个事件: `render`, `update`. 分别在模板渲染和模板更新是触发.\n\n这两个事件是通过 jQuery 绑定在 `view.el` 上的. 使用 jQuery 的 `$(view.el).on` 方法可以监听到这两个事件.\n\n另外需要注意的一点是: 这两个事件是**不冒泡**的. 如下面的监听函数在执行 `view.render` 时不会被触发:\n\n```javascript\n$('#view-container').on('render', function(){\n  //这里不会执行\n  alert('会冒泡吗?')\n})\n```","note":"<h3>ZUI View 的事件</h3>\n<p>ZUI View 目前自带有两个事件: <code>render</code>, <code>update</code>. 分别在模板渲染和模板更新是触发.</p>\n<p>这两个事件是通过 jQuery 绑定在 <code>view.el</code> 上的. 使用 jQuery 的 <code>$(view.el).on</code> 方法可以监听到这两个事件.</p>\n<p>另外需要注意的一点是: 这两个事件是<strong>不冒泡</strong>的. 如下面的监听函数在执行 <code>view.render</code> 时不会被触发:</p>\n<pre><code class=\"lang-javascript\"><span class=\"variable\">$(</span><span class=\"string\">'#view-container'</span>).on(<span class=\"string\">'render'</span>, function(){\n  <span class=\"regexp\">//</span>这里不会执行\n  alert(<span class=\"string\">'会冒泡吗?'</span>)\n})</code></pre>\n","html":"<div id='view-container'>\n  <p id='view'>update 和 render 事件其实是一个自定义的 DOM 事件!</p>\n</div>","javascript":"var view = new ZUI.View(document.getElementById('view'));\n                        \nview.on('render', function(){\n  alert('render');\n});\n\n$('#view-container').on('render', function(){\n  //这里不会执行\n  alert('会冒泡吗?')\n})","console":"view.render({})","fixCode":{"javascript":"var view = new ZUI.View(document.getElementById('view'));\n                        \nview.on('render', function(){\n  alert('render');\n});\n\n$('#view-container').on('render', function(){\n  //这里不会执行\n  alert('会冒泡吗?')\n})"}},{"noteMarked":"### events 选项\n\nZUI View 构造函数的选项参数中可接收一个 `events` 选项, 该选项当中可以编写所有的可委托事件处理函数. 如果你使用过 [backbone][1], 应该会很熟悉.\n\n```\nvar view = new ZUI.View(document.getElementById('view'), {\n  events: {\n    'click button': function() {\n      alert('点击了按钮')\n    },\n    'render': function(){\n      alert('渲染完毕');\n    }\n  }\n});\n```\n这种将事件集中起来的写法, 对我们的代码组织大有帮助.\n\n[1]:http://documentcloud.github.io/backbone/#View-delegateEvents","note":"<h3>events 选项</h3>\n<p>ZUI View 构造函数的选项参数中可接收一个 <code>events</code> 选项, 该选项当中可以编写所有的可委托事件处理函数. 如果你使用过 <a href=\"http://documentcloud.github.io/backbone/#View-delegateEvents\">backbone</a>, 应该会很熟悉.</p>\n<pre><code><span class=\"keyword\">var</span> view = <span class=\"keyword\">new</span> ZUI.View(document.getElementById(<span class=\"string\">'view'</span>), {\n  events: {\n    <span class=\"string\">'click button'</span>: <span class=\"keyword\">function</span>() {\n      alert(<span class=\"string\">'点击了按钮'</span>)\n    },\n    <span class=\"string\">'render'</span>: <span class=\"keyword\">function</span>(){\n      alert(<span class=\"string\">'渲染完毕'</span>);\n    }\n  }\n});</code></pre>\n<p>这种将事件集中起来的写法, 对我们的代码组织大有帮助.</p>\n","html":"<div id='view-container'>\n  <p id='view'>update 和 render 事件其实是一个自定义的 DOM 事件!\n    <button class='btn btn-primary'>按钮</button>\n  </p>\n</div>","javascript":"var view = new ZUI.View(document.getElementById('view'), {\n  events: {\n    'click button': function() {\n      alert('点击了按钮')\n    },\n    'render': function(){\n      alert('渲染完毕');\n    }\n  }\n});","console":"view.render({})"},{"noteMarked":"### 使用自定义事件\n\n使用 `trigger` 方法能够触发一个自定义事件. 该事件会像普通的 DOM 事件一样沿着 DOM 树向上冒泡. 例如, 有两个嵌套的模板:\n\n```javascript\nvar view1 = new ZUI.View($('#view')[0], {data: {}});\nvar view2 = new ZUI.View($('#view-container')[0], {data: {}});\nview2.on('custom', function(e, data) {\n  alert('view1 的数据: ' + data);\n})\n```\n\n这个两个模板或者说组件(component)之间的交互, 可以通过事件来完成. \n\n __事件驱动__是 javascript 编程的核心概念之一. 使用自定义事件代替方法调用是前端程序解除耦合的利器.","note":"<h3>使用自定义事件</h3>\n<p>使用 <code>trigger</code> 方法能够触发一个自定义事件. 该事件会像普通的 DOM 事件一样沿着 DOM 树向上冒泡. 例如, 有两个嵌套的模板:</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> view1 = <span class=\"keyword\">new</span> ZUI.View($(<span class=\"string\">'#view'</span>)[<span class=\"number\">0</span>], {data: {}});\n<span class=\"keyword\">var</span> view2 = <span class=\"keyword\">new</span> ZUI.View($(<span class=\"string\">'#view-container'</span>)[<span class=\"number\">0</span>], {data: {}});\nview2.on(<span class=\"string\">'custom'</span>, <span class=\"keyword\">function</span>(e, data) {\n  alert(<span class=\"string\">'view1 的数据: '</span> + data);\n})</code></pre>\n<p>这个两个模板或者说组件(component)之间的交互, 可以通过事件来完成. </p>\n<p> <strong>事件驱动</strong>是 javascript 编程的核心概念之一. 使用自定义事件代替方法调用是前端程序解除耦合的利器.</p>\n","html":"<div id='view-container'>\n  <p id='view'>非阻塞和事件驱动是 javascript 编程的两个核心概念. </p>\n</div>","javascript":"var view1 = new ZUI.View($('#view')[0], {data: {}});\nvar view2 = new ZUI.View($('#view-container')[0], {data: {}});\nview2.on('custom', function(e, data) {\n  alert('view1 的数据: ' + data);\n})","console":"view1.trigger('custom', 'Ant')","autorun":true}],"title":"事件委托"},{"steps":[{"note":"<p>ZUI View 提供了一种简便的方式来提供扩展功能.</p>\n<p>使用 ZUI.View 构造函数的 <code>extend</code> 方法可以构建一个新的构造函数:</p>\n<pre><code class=\"lang-javascript\"><span class=\"keyword\">var</span> MyView = ZUI.View.extend({\n  showName: <span class=\"keyword\">function</span>() {\n    alert(<span class=\"keyword\">this</span>.data.name)\n  }\n});\n\n<span class=\"keyword\">var</span> view = <span class=\"keyword\">new</span> MyView($(<span class=\"string\">'#view'</span>)[<span class=\"number\">0</span>], {\n  data: {name: <span class=\"string\">'Ant'</span>},\n  events: {\n    <span class=\"string\">'click button'</span>: <span class=\"keyword\">function</span>() {\n      <span class=\"keyword\">this</span>.showName();\n    }\n  }\n})</code></pre>\n<p><code>ZUI.VIew.extend</code> 方法接收两个对象参数:</p>\n<ol>\n<li>第一个参数扩展其原型. 该构造函数的所有实例对象都将获得这些属性或方法.</li>\n<li>第二个参数扩展其构造函数方法和属性, 也就是静态方法. </li>\n</ol>\n","noteMarked":"ZUI View 提供了一种简便的方式来提供扩展功能.\n\n使用 ZUI.View 构造函数的 `extend` 方法可以构建一个新的构造函数:\n\n```javascript\nvar MyView = ZUI.View.extend({\n  showName: function() {\n    alert(this.data.name)\n  }\n});\n\nvar view = new MyView($('#view')[0], {\n  data: {name: 'Ant'},\n  events: {\n    'click button': function() {\n      this.showName();\n    }\n  }\n})\n```\n`ZUI.VIew.extend` 方法接收两个对象参数:\n\n  1. 第一个参数扩展其原型. 该构造函数的所有实例对象都将获得这些属性或方法.\n  2. 第二个参数扩展其构造函数方法和属性, 也就是静态方法. \n","html":"<div id='view'>\n  Name: {{name}}\n  <button class=\"btn btn-primary\">Show name</button>\n</div>","javascript":"var MyView = ZUI.View.extend({\n  showName: function() {\n    alert(this.data.name)\n  }\n});\n\nvar view = new MyView($('#view')[0], {\n  data: {name: 'Ant'},\n  events: {\n    'click button': function() {\n      this.showName();\n    }\n  }\n})","console":"view.set('name', 'Bee');\nview.showName();"}],"title":"扩展 ZUI View"}]